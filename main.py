from PIL import Image#Библиотека для работы с изображениями
import numpy as np#Данную библиотеку я использовал для работы с двумерными массивами
import math#Использовал для логарифма
def privet():    #Функция для оформления
    print("Добро пожаловать")
    print("1: Зашифровать")
    print("2: Расшифровать")
    print("3: Сравнить оригинальное изображение и изображение с зашифрованной информацией")
    check = input()
    if check == '1':
        print("1: Зашифровать текст")
        print("2: Зашифровать изображение")
        print("3: Зашифровать Бинарную последовательность")
        check2=input()
        if check2=='1':
            print("Введите путь до изображения")
            print("В случае, если изображение в папке с программой, напишите название фотографии с его типом")
            print("Например: 123.png")
            depart = input()
            print("Введите текст сообщения, которое вы хотите зашифровать")
            message = input()
            print("Введите секретное стоп-слово, это набор символов, который никогда не встретится в тексте")
            stop=input()
            print("Введите место, куда вы хотите сохранить картинку с зашифрованным сообщением")
            destin = input()
            print("Введите число наименее значимых битов(больше нуля), которое вы хотите замещать")
            print("Желательно от 1 до 4")
            q=int(input())
            print("Какие слои вы хотите закодировать. Пишите большими буквами R,G,B или их комбинации в нужном порядке")
            check3=input()
            encode(depart, message, stop, destin, q,check3)
        elif check2=='2':
            print("Введите путь до изображения")
            print("В случае, если изображение в папке с программой, напишите название фотографии с его типом")
            print("Например: 123.png")
            depart = input()
            print("Введите путь до изображения, которое вы хотите вставить")
            print("В случае, если изображение в папке с программой, напишите название фотографии с его типом")
            print("Например: 1234.png")
            depart2=input()
            print("Введите секретное стоп-слово, это набор символов, который никогда не встретится в тексте")
            stop = input()
            print("Введите место, куда вы хотите сохранить картинку с зашифрованным изображением")
            destin = input()
            print("Введите число наименее значимых битов(больше нуля), которое вы хотите замещать")
            print("Желательно от 1 до 4")
            q=int(input())
            print("Какие слои вы хотите закодировать. Пишите большими буквами R,G,B или их комбинации в нужном порядке")
            check3 = input()
            encode_img(depart, depart2,stop, destin,q, check3)
        elif check2=='3':
            print("Введите путь до изображения")
            print("В случае, если изображение в папке с программой, напишите название фотографии с его типом")
            print("Например: 123.png")
            depart = input()
            print("Введите бинурную последовательность")
            message=input()
            print("Введите секретное стоп-слово, это набор символов, который никогда не встретится в тексте")
            stop = input()
            print("Введите место, куда вы хотите сохранить картинку с зашифрованным изображением")
            destin = input()
            print("Введите число наименее значимых битов(больше нуля), которое вы хотите замещать")
            print("Желательно от 1 до 4")
            q=int(input())
            print("Какие слои вы хотите закодировать. Пишите большими буквами R,G,B или их комбинации в нужном порядке")
            check3 = input()
            encode_bin(depart, message,stop, destin, q, check3)
        else:
            print("Ошибка: введено не то число")
    elif check == '2':
        print("1: Расшифровать текст")
        print("2: Расшифровать изображение")
        print("3: Расшифровать бинарную последовательность")
        check2 = input()
        if check2 == '1':
            print("Введите путь до изображения")
            print("В случае, если изображение в папке с программой, напишите название фотографии с его типом")
            print("Например: 123.png")
            depart = input()
            print("Введите число наименее значимых битов(больше нуля), которые заменялись при кодировании")
            q=int(input())
            print("Введите секретное стоп-слово, с которым было зашифровано сообщение")
            stop = input()
            print("Какие слои которыми было закодировано сообщение. Пишите большими буквами R,G,B или их комбинации в нужном порядке")
            check3 = input()
            decode(depart,q,stop, check3)
        elif check2 == '2':
            print("Введите путь до изображения")
            print("В случае, если изображение в папке с программой, напишите название фотографии с его типом")
            print("Например: 123.png")
            depart = input()
            print("Введите секретное стоп-слово, с которым было зашифровано сообщение")
            stop = input()
            print("Введите место, куда вы хотите сохранить расшифрованную картинку")
            destin = input()
            print("Введите число наименее значимых битов(больше нуля), которые заменялись при кодировании")
            q=int(input())
            print("Какие слои которыми было закодировано сообщение. Пишите большими буквами R,G,B или их комбинации в нужном порядке")
            check3 = input()
            decode_img(depart,stop, destin, q,check3)
        elif check2=='3':
            print("Введите путь до изображения")
            print("В случае, если изображение в папке с программой, напишите название фотографии с его типом")
            print("Например: 123.png")
            depart = input()
            print("Введите секретное стоп-слово, с которым было зашифровано сообщение")
            stop = input()
            print("Введите число наименее значимых битов(больше нуля), которые заменялись при кодировании")
            q=int(input())
            print("Какие слои которыми было закодировано сообщение. Пишите большими буквами R,G,B или их комбинации в нужном порядке")
            check3 = input()
            decode_bin(depart, stop, q, check3)
        else:
            print("Ошибка: введено не то число")
    elif check=='3':
        print("Введите путь до оригинала изображения")
        depart = input()
        print("Введите путь зашифрованного изображения")
        depart2=input()
        print("Введите место, куда вы хотите сохранить картинку с итоговой разницей")
        destin = input()
        sravnenie(depart,depart2,destin)
    else:
        print("Ошибка: введено не то число")
def PSNR(vsego_pix,posled,h,w,posledMSE):#Функция для расчета качества встраивания
    polMSE=0
    maxi=0
    for i in range(vsego_pix):#Запускаю цикл по размеру изображения
        for k in range(0, 3):#Запускаю цикл по слоям RGB
            polMSE += int((posled[i][k] - posledMSE[i][k])) ** 2 #считаю часть формулы MSE
            if posled[i][k] > maxi:#Нахожу максимальное значение слоя в изображении
                maxi = posled[i][k]
    MSE = polMSE / (h * w * 3)#считаю MSE
    PSNR = 10 * math.log10((maxi ** 2) / MSE) #Считаю PSNR
    return PSNR
def binary(message):#Функция перевода символа в бинарный вид
    message_txt=''
    for i in message:#Запускаю цикл по сообщению
        check=bin(ord(i))#Беру двоичное значение символа символа по ASCII
        check=check.replace('0b','')#Убираю ob из строки, так как в питоне при использовании bin в начале ставится 0b
        if len(check)<8:#дополняю до длины в 8 символов
            check = '0'*(8-len(check))+check
        message_txt+=check#К итоговой строке добавляю 8 символов
    return message_txt
def RGB(check3): #Функция определения по какому промежутку бежать циклу в питоне в будущем
    rangers=''
    if check3=='R':
        rangers=range(0,1)
    elif check3=='G':
        rangers=range(1,2)
    elif check3=='B':
        rangers=range(2,3)
    elif check3=='RG':
        rangers=range(0,2)
    elif check3=='GB':
        rangers=range(1,3)
    elif check3=='RB':
        rangers=range(0,3,2)
    elif check3=='RGB':
        rangers=range(3)
    return rangers
def encode(depart, message,stop, destin, q,check3):#Функция шифровки текста в изображение
    img=Image.open(depart,'r')#Открываю изображение
    w,h=img.size#Получаю его размеры
    posled=np.array(list(img.getdata()))#Создаю двумерный массив с помощью библиотеки numpy, в котором хранится информация о кажом пикселе
    posledMSE=posled.copy()#копирую массив из прошлой строки
    vsego_pix=len(list(img.getdata()))#Количество пикселей
    message+=stop #Секретное сообщение
    if img.mode == 'RGBA':#Делаю проверку какое у меня изображение RGB или RGBA
        mode = 4
    elif img.mode == 'RGB':
        mode = 3
    message_txt=binary(message)#С помощью функции описанной выше перевожу текст с секретным сообщением в бинарный вид
    check2=len(message_txt)#Беру длину бинарного вида всего текста
    counter=0
    kolvopix=0
    rangers=RGB(check3)#Определяю по какому циклу в зависимости от введенных слоев идти программе
    if check2<vsego_pix*q*len(check3):#Делаю проверку, что сообщение вместится
        for i in range(vsego_pix):#Запускаю цикл по размеру изображения
            for k in rangers:#Запускаю цикл выбранным слоям
                if check2>=counter:#Проверка не кончилось ли сообщение
                    if k==min(rangers):#Считаю, количество замещенных пикселей
                        kolvopix+=1
                    c=bin(posled[i][k])#Перевожу в бинарный вид параметр слоя
                    c = c.replace('0b', '')#Убираю ob из строки, так как в питоне при использовании bin в начале ставится 0b
                    if len(c) < 8:  # дополняю до длины в 8 символов
                        c = '0' * (8 - len(c)) + c
                    c=c[:len(c)-q]#Убираю последние наименее значимые биты в зависимости от введенных значений пользователя
                    posled[i][k]=int(c+message_txt[counter:counter+q],2)#вместо наименее значимых битов вставляется бинарная последовательность
                    counter += q#увеличиваем счетчик на длину использованных битов, чтобы брать следующие
        PSNRi=PSNR(vsego_pix,posled,h,w,posledMSE)#Посчитали PSNR с помощью описанной выше функции
        posled = posled.reshape(h, w, mode)#В следующих строчках до конца функции строю получившееся изображение с помощью получившейся матрицы
        enc_img = Image.fromarray(posled.astype('uint8'), img.mode)
        enc_img.save(destin)
        print('Количество замещенных пикселей', kolvopix)
        print('PSNR', PSNRi)
    else:
        print('Слишком длинное сообщение')
def decode(depart,q,stop,check3):#Функция расшифровки текста из изображения
    img = Image.open(depart, 'r') #Открываю изображение
    posled = np.array(list(img.getdata()))#Создаю двумерный массив с помощью библиотеки numpy, в котором хранится информация о кажом пикселе
    vsego_pix = len(list(img.getdata())) #Количество пикселей
    pix=''
    rangers=RGB(check3) #Определяю по какому циклу в зависимости от введенных слоев идти программе
    for i in range(vsego_pix):#Запускаю цикл по размеру изображения
        for k in rangers:#Запускаю цикл выбранным слоям
            c=bin(posled[i][k])#Перевожу в бинарный вид параметр слоя
            c = c.replace('0b', '')#Убираю ob из строки, так как в питоне при использовании bin в начале ставится 0b
            if len(c) < 8:# дополняю до длины в 8 символов
                c = '0' * (8 - len(c)) + c
            a=c[-q:]#Беру срез наимение значимых битов
            pix+=a#Создаю строку наимение значимых битов
    message=''
    message_check=''
    n=0
    for i in range(len(pix)):#Запускаю цикл по длине строки среза наименее значимых символов
        if message[-len(stop):] == stop:#Если программа встречает секретное стоп-слово, то она выходит из цикла
            n=1
            break
        else:
            message_check+=pix[i]# Увеличиваю переменную, пока ее длина не станет равной 8
            if len(message_check)==8:#Проверяем равна ли длин 8
                if int(message_check, 2)>=32 and int(message_check, 2)<127:#Делаем проверку, что по таблице ASCII символ является печатным
                    message += chr(int(message_check, 2))# перевожу последовательность в символ
                message_check=''#Обнуляем проверочную переменную
    if n==1:
        print(message[:-len(stop)])#вывожу итоговое сообщение
    else:
        print('Нет спрятанного сообщения')
def encode_img(depart, depart2, stop, destin,q, check3):#Функция шифровки изображения в изображение
    img=Image.open(depart,'r')#Открываю изображение
    w,h=img.size#Получаю его размеры
    posled=np.array(list(img.getdata()))#Создаю двумерный массив с помощью библиотеки numpy, в котором хранится информация о кажом пикселе
    posledMSE = posled.copy()#копирую массив из прошлой строки
    vsego_pix=len(list(img.getdata()))#Количество пикселей
    img2=Image.open(depart2,'r')#Открываю изображение, которое буду кодировать
    w2, h2 = img2.size#Получаю его размеры
    posled2 = np.array(list(img2.getdata()))#Создаю двумерный массив с помощью библиотеки numpy, в котором хранится информация о кажом пикселе
    vsego_pix2 = len(list(img2.getdata()))#Количество пикселей
    img.txt=''
    pix2=''
    if img.mode == 'RGBA':#Делаю проверку какое у меня изображение RGB или RGBA
        mode = 4
    elif img.mode == 'RGB':
        mode = 3
    for i in range(vsego_pix2):#Запускаю цикл для перевода изображения в бинарный вид, цикл запускается по количеству пикселей
        for k in range(0,3):#Запускаю цикл по слоям RGB
            p=bin(posled2[i][k])#Перевожу в бинарный вид параметр слоя
            p = p.replace('0b', '')#Убираю ob из строки, так как в питоне при использовании bin в начале ставится 0b
            if len(p) < 8:# дополняю до длины в 8 символов
                p = '0' * (8 - len(p)) + p
            pix2+=p #получаю изображение которое хочу закодировать в полностью бинарном виде
    message = stop+str(w2)+'x'+str(h2)+stop#Ставлю стоп-слово потом размещаю размеры кодирующегося изображения и снова ставлю стоп-слово
    pix2 += binary(message)#Перевожу строчку выше в бинарный вид и ставлю после кодирующегося изображения
    check2=len(pix2)# беру длину итоговой бинарной последовательности
    counter=0
    kolvopix =0
    rangers=RGB(check3)#Определяю по какому циклу в зависимости от введенных слоев идти программе
    if check2<vsego_pix*q*len(check3):#Делаю проверку, что сообщение вместится
        for i in range(vsego_pix):#Запускаю цикл по размеру изображения
            for k in rangers:#Запускаю цикл выбранным слоям
                if check2 >= counter:#Проверка не кончилось ли сообщение
                    if k == min(rangers):#Считаю, количество замещенных пикселей
                        kolvopix += 1
                    c = bin(posled[i][k])#Перевожу в бинарный вид параметр слоя
                    c = c.replace('0b', '')#Убираю ob из строки, так как в питоне при использовании bin в начале ставится 0b
                    if len(c) < 8:# дополняю до длины в 8 символов
                        c = '0' * (8 - len(c)) + c
                    c = c[:len(c) - q]#Убираю последние наименее значимые биты в зависимости от введенных значений пользователя
                    posled[i][k] = int(c + pix2[counter:counter+q], 2)#вместо наименее значимых битов вставляется текст
                    counter+=q#увеличиваем счетчик на длину использованных битов, чтобы брать следующие
        PSNRi = PSNR(vsego_pix, posled, h, w, posledMSE)#Посчитали PSNR с помощью описанной выше функции
        posled = posled.reshape(h, w, mode)#В следующих строчках до конца функции строю получившееся изображение с помощью получившейся матрицы
        enc_img = Image.fromarray(posled.astype('uint8'), img.mode)
        enc_img.save(destin)
        print('Количество замещенных пикселей', kolvopix)
        print('PSNR', PSNRi)
    else:
        print('Слишком большая фотография')
def decode_img(depart,stop, destin,q, check3):#Функция для расшифровки изображения из изображения
    img = Image.open(depart, 'r')#Открываю изображение
    posled = np.array(list(img.getdata()))#Создаю двумерный массив с помощью библиотеки numpy, в котором хранится информация о кажом пикселе
    vsego_pix = len(list(img.getdata()))#Количество пикселей
    if img.mode == 'RGBA':#Делаю проверку какое у меня изображение RGB или RGBA
        mode = 4
    elif img.mode == 'RGB':
        mode = 3
    pix = ''
    rangers = RGB(check3) #Определяю по какому циклу в зависимости от введенных слоев идти программе
    for i in range(vsego_pix):#Запускаю цикл по размеру изображения
        for k in rangers:#Запускаю цикл выбранным слоям
            c = bin(posled[i][k])#Перевожу в бинарный вид параметр слоя
            c = c.replace('0b', '')#Убираю ob из строки, так как в питоне при использовании bin в начале ставится 0b
            if len(c) < 8:#дополняю до длины в 8 символов
                c = '0' * (8 - len(c)) + c
            a = c[-q:]#Беру срез наимение значимых битов
            pix += a#Создаю строку наимение значимых битов
    message = ''
    message_check = ''
    counter=0
    message1=''
    n=0
    for i in range(len(pix)):#Запускаю цикл по длине строки среза наименее значимых символов
        if message1[-len(stop):]==stop:#Если программа встречает секретное стоп-слово, то она выходит из цикла
            n=1
            break
        else:
            message_check+=pix[i]# Увеличиваю переменную, пока ее длина не станет равной 8
            counter += 1#Увеличиваю счетчик на 1, онпонадобится в будущем
            if len(message_check) == 8:#Проверяем равна ли длин 8
                message += str(int(message_check, 2))#перевожу параметр слоя в десятичное число
                if int(message_check, 2) >= 32 and int(message_check, 2) < 127:#Делаем проверку, что по таблице ASCII символ является печатным
                    message1 += chr(int(message_check, 2))# перевожу последовательность в символ
                message_check = ''#Обнуляем проверочную переменную
    if n==1:
        pix3 = pix[counter:]#Так как программа программа нашла стоп-слово, то мы делаем срез начиная именного с него, для того, чтобы теперь определить размеры
        message_check = ''
        message = ''
        for i in range(len(pix3)):#Запускаю цикл по длине строки в формате длина-x-шириша-стопслово-остальной текст
            if message[-len(stop):] == stop:#Если программа встречает секретное стоп-слово, то она выходит из цикла
                break
            else:
                message_check+=pix3[i]# Увеличиваю переменную, пока ее длина не станет равной 8
                if len(message_check)==8:#Проверяем равна ли длин 8
                    if int(message_check, 2)>=32 and int(message_check, 2)<127:#Делаем проверку, что по таблице ASCII символ является печатным
                        message += chr(int(message_check, 2))# перевожу последовательность в символ
                    message_check=''#Обнуляем проверочную переменную
        size=message[:-len(stop)]#Делаю срез до 2 стоп-слова и у меня остается строка длина-х-ширина
        w=int(size[:size.index('x')])#получаю ширину
        h=int(size[size.index('x')+1:])#получаю высоту
        message_check=''
        img2=Image.new('RGBA', (w, h),'white')#Создаю пустое белое изображение
        posled2=np.array(list(img2.getdata()))#Создаю двумерный массив с помощью библиотеки numpay, в котором хранится информация о кажом пикселе
        t=0
        k=0
        pix = pix[:w * h * 3 * 8]#Делаю срез из полной строки состоящих из срезанных наименее значимых битов использованных при шифровании по размеру фотографии
        for i in range(len(pix)):#Запускаю цикл по длине строки среза наименее значимых символов
            message_check+=pix[i]# Увеличиваю переменную, пока ее длина не станет равной 8
            if len(message_check) == 8:# Увеличиваю переменную, пока ее длина не станет равной 8
                message=str(int(message_check, 2))#перевожу параметр слоя в десятичное число
                message_check=''
                posled2[t][k]=int(message)#В белом изображении заменяю слой на нужное, получившееся изображение
                if k==2:
                    k=-1
                    t += 1
                k += 1
        posled2 = posled2.reshape(h, w, 4)#В следующих строчках до конца функции строю получившееся изображение с помощью получившейся матрицы
        enc_img = Image.fromarray(posled2.astype('uint8'), img.mode)
        enc_img.save(destin)
    else:
        print('Нет спрятанного сообщения')
def encode_bin(depart, message,stop, destin,q, check3):#Функция для кодировки бинарной последовательности в изображение
    img = Image.open(depart, 'r')#Открываю изображение
    w, h = img.size#Получаю его размеры
    posled = np.array(list(img.getdata()))#Создаю двумерный массив с помощью библиотеки numpy, в котором хранится информация о кажом пикселе
    vsego_pix = len(list(img.getdata()))#Количество пикселей
    posledMSE = posled.copy()#копирую массив из прошлой строки
    binp=message#Присваю переменной введенную бинарную последовательность
    message = binary(stop)#перевожу стоп-слово в бинарный вид
    if img.mode == 'RGBA':#Делаю проверку какое у меня изображение RGB или RGBA
        mode = 4
    elif img.mode == 'RGB':
        mode = 3
    binp+=message#прибавляю к введенной бинарной последовательности бинарный вид стоп-слова
    check2 = len(binp)#Беру длину итоговой последовательности, которую буду кодировать
    counter = 0
    kolvopix =0
    rangers=RGB(check3)#Определяю по какому циклу в зависимости от введенных слоев идти программе
    if check2 < vsego_pix*q*len(check3)//3:#Делаю проверку, что сообщение вместится
        for i in range(vsego_pix):#Запускаю цикл по размеру изображения
            for k in rangers:#Запускаю цикл выбранным слоям
                if check2 >= counter:#Проверка не кончилось ли сообщение
                    if k == min(rangers):#Считаю, количество замещенных пикселей
                        kolvopix += 1
                    c = bin(posled[i][k])#Перевожу в бинарный вид параметр слоя
                    c = c.replace('0b', '')#Убираю ob из строки, так как в питоне при использовании bin в начале ставится 0b
                    if len(c) < 8:# дополняю до длины в 8 символов
                        c = '0' * (8 - len(c)) + c
                    c = c[:len(c) - q]#Убираю последние наименее значимые биты в зависимости от введенных значений пользователя
                    posled[i][k] = int(c + binp[counter:counter+q], 2)#вместо наименее значимых битов вставляется бинарная последовательность
                    counter += q#увеличиваем счетчик на длину использованных битов, чтобы брать следующие
        PSNRi = PSNR(vsego_pix, posled, h, w, posledMSE)#Посчитали PSNR с помощью описанной выше функции
        posled = posled.reshape(h, w, mode)#В следующих строчках до конца функции строю получившееся изображение с помощью получившейся матрицы
        enc_img = Image.fromarray(posled.astype('uint8'), img.mode)
        enc_img.save(destin)
        print('Количество замещенных пикселей', kolvopix)
        print('PSNR', PSNRi)
    else:
        print('Слишком длинное сообщение')
def decode_bin(depart,stop,q, check3):#Функция расшифровки бинарной последовательности
    img = Image.open(depart, 'r')#Открываю изображение
    posled = np.array(list(img.getdata()))#Создаю двумерный массив с помощью библиотеки numpy, в котором хранится информация о кажом пикселе
    vsego_pix = len(list(img.getdata()))#Количество пикселей
    pix=''
    rangers = RGB(check3)#Определяю по какому циклу в зависимости от введенных слоев идти программе
    for i in range(vsego_pix):#Запускаю цикл по размеру изображения
        for k in rangers:#Запускаю цикл выбранным слоям
            c = bin(posled[i][k])#Перевожу в бинарный вид параметр слоя
            c = c.replace('0b', '')#Убираю ob из строки, так как в питоне при использовании bin в начале ставится 0b
            if len(c) < 8:# дополняю до длины в 8 символов
                c = '0' * (8 - len(c)) + c
            a = c[-q:]#Беру срез наимение значимых битов
            pix += a#Создаю строку наимение значимых битов
    message_txt=binary(stop)#Перевожу стоп-слово в бинарный вид
    message_check=''
    n=0
    for i in range(len(pix)):#Запускаю цикл по длине строки среза наименее значимых символов
        if message_check[-len(message_txt):] == message_txt:#Если программа встречает секретное стоп-слово, то она выходит из цикла
            n=1
            break
        else:
            message_check+=pix[i]#Получаю свою бинарную последовательность
    if n==1:
        message=message_check[:-len(message_txt)]
        print(message)
    else:
        print('Нет спрятанного сообщения')
def sravnenie(depart,depart2, destin):#Сравнение двух изображений
    img = Image.open(depart, 'r')#Открываю изображение
    posled = np.array(list(img.getdata()))#Создаю двумерный массив с помощью библиотеки numpy, в котором хранится информация о кажом пикселе
    w, h = img.size#Получаю его размеры
    if img.mode == 'RGBA':#Делаю проверку какое у меня изображение RGB или RGBA
        mode = 4
    elif img.mode == 'RGB':
        mode = 3
    vsego_pix=len(list(img.getdata()))#Количество пикселей
    img2 = Image.open(depart2, 'r')#Открываю изображение2
    posled2 = np.array(list(img2.getdata()))#Создаю двумерный массив с помощью библиотеки numpay, в котором хранится информация о кажом пикселе
    for i in range(vsego_pix):#Запускаю цикл по размеру изображения
        for k in range(0, 3):#Запускаю цикл по RGB
            if posled[i][k]!=posled2[i][k]:#Сравниваю пиксели
                posled[i][0]=255#Закрашиваю красным неодинаковый пиксель
    posled = posled.reshape(h, w, mode)#В следующих строчках до конца функции строю получившееся изображение с помощью получившейся матрицы
    enc_img = Image.fromarray(posled.astype('uint8'), img.mode)
    enc_img.save(destin)
print(privet())